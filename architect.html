<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="assets/blockforge.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockForge Architect - Realty Engine</title>
    <script src="assets/theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="assets/partials/partials-loader.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Work+Sans:wght@300;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/themes.css">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Work Sans',sans-serif;background:var(--bg-primary);color:var(--text-primary);overflow-x:hidden; transition: background 0.3s, color 0.3s;}
        
        .sidebar { background:var(--bg-secondary); border-radius:16px; padding:1.5rem; box-shadow:0 4px 24px var(--shadow-primary); display: flex; flex-direction: column; gap: 1.5rem; }
        
        .control-group { margin-bottom: 1rem; }
        label { display: block; font-size: 0.85rem; font-weight: 700; margin-bottom: 0.5rem; color: var(--text-muted); text-transform: uppercase; }
        input[type="range"] { width: 100%; accent-color: var(--accent-primary); }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 0 2rem 4rem; }
        .workspace { display: grid; grid-template-columns: 1fr 380px; gap: 2rem; margin-top: 2rem; }
        .viewer-container { background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 4px 24px rgba(13,43,62,0.15); position: relative; }
        #canvas-container { width: 100%; height: 600px; background: linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%); border-radius: 12px; position: relative; overflow: hidden; }
        .viewer-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem}
        .viewer-header h2{font-size:1.5rem;font-weight:700;color:var(--text-primary); margin-bottom: 0;}
        .view-controls{display:flex;gap:.5rem;}

        
        .stats { background: var(--bg-tertiary); color: var(--text-secondary); padding: 15px; border-radius: 8px; font-size: 0.85rem; font-family: 'Space Mono', monospace; }
        #image-preview {
            width: 100%;
            height: 180px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 10px;
            display: none;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
        }
        .hero{max-width:1400px;margin:3rem auto;padding:0 2rem;text-align:center}
        .hero h1{font-size:3.5rem;font-weight:800;line-height:1.1;margin-bottom:1rem;color: var(--text-primary);}
        .hero .subtitle{font-size:1.125rem;color:var(--text-muted);max-width:600px;margin:0 auto 2rem;line-height:1.6}
    </style>
</head>
<body>
<div data-partial="nav" data-tool-title="Architect Tool"></div>

<!-- Hero Section -->
<section class="hero">
    <h1>Architect Studio</h1>
    <p class="subtitle">Transform a photograph of a house into a stunning 3D brick facade. The perfect high-end closing gift for real estate professionals.</p>
</section>

<div class="container">
    <div class="workspace">
        <div class="viewer-container">
            <div class="viewer-header">
                <h2>3D Facade Preview</h2>
                <div class="view-controls"><button class="btn btn-outline" onclick="setTopView()">Top View</button></div>
            </div>
            <div id="canvas-container"></div>
        </div>
        <div class="sidebar">
        <!-- Edition label removed for consistency with 3D.html header -->
        <div class="control-group">
            <label>1. Upload House Photo</label>
            <img id="image-preview">
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn btn-secondary" onclick="document.getElementById('file-input').click()" style="flex:2;">üìÅ Select Image</button>
                <button class="btn btn-outline" onclick="removeImage()" title="Remove image and clear the scene" style="flex:1;">Clear</button>
            </div>
            <input type="file" id="file-input" accept="image/*" style="display: none" onchange="handleImageUpload(this)">
        </div>
        <!-- The Architect tool uses a specific masonry color palette defined in its script. -->
        <div class="control-group">
            <label>2. Model Settings</label>
            <div>Size (Baseplate Width): <span id="size-val">48</span> studs <span id="estimated-size" style="font-size:0.8rem; color: var(--text-muted);"></span></div>
            <input type="range" id="size-slider" min="32" max="96" step="16" value="48" oninput="updateSettings()" title="Baseplate Width in studs">
            <div style="margin-top:10px;">Relief Depth: <span id="depth-val">15</span> bricks</div>
            <input type="range" id="depth-slider" min="5" max="30" value="15" oninput="updateSettings()" title="Relief Depth in bricks">
            <div style="margin-top:10px;">Detail/Contrast:</div>
            <input type="range" id="contrast-slider" min="0" max="3" step="0.1" value="1.2" oninput="updateSettings()" title="Adjust detail and contrast">
        </div>
        <div class="stats" id="stats-panel">
            Upload an image to calculate bricks.
        </div>
        <button class="btn btn-primary" onclick="generatePDF()">üìÑ Export Realtor Guide</button>
    </div>


    </div>
</div>

<script>
    // --- Architecture Palette (Masonry Focus) ---
    const archColors = [
        { r:255, g:255, b:255, name: 'White', hex: '#FFFFFF' },      // Windows/Trim
        { r:155, g:155, b:155, name: 'Lt Stone', hex: '#9BA19D' },   // Stone
        { r:100, g:100, b:100, name: 'Dk Stone', hex: '#635F52' },   // Roof/Asphalt
        { r:27, g:42, b:52,    name: 'Black', hex: '#1B2A34' },      // Shadows/Depth
        { r:150, g:50, b:50,   name: 'Brick Red', hex: '#8B0000' },  // Bricks
        { r:210, g:180, b:140, name: 'Tan', hex: '#D2B48C' },        // Stucco/Wood
        { r:90, g:70, b:40,    name: 'Dark Tan', hex: '#362313' },   // Timber
        { r:50, g:80, b:50,    name: 'Dk Green', hex: '#237841' }    // Landscaping
    ];

    let scene, camera, renderer, controls, mesh;
    let originalImage = null;
    let isMouseDown = false, previousMousePosition = { x: 0, y: 0 };
    let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    let debouncedProcessImage;

    function init() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 60, 60);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Architectural Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 50, 20);
        sun.castShadow = true;
        scene.add(sun);

        // Ground
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add event listeners for camera control
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });

        // Debounce the expensive image processing function
        debouncedProcessImage = debounce(processImage, 300);

        updateSettings(); // Set initial estimated size
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    // --- Camera Controls ---
    function onMouseDown(e) {
        isMouseDown = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
        if (!isMouseDown) return;

        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        const target = new THREE.Vector3(0, 10, 0); // Orbit around the center of the scene
        const offset = camera.position.clone().sub(target);

        // Rotate around world Y axis for horizontal drag
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
        // Rotate around camera's local X axis for vertical drag
        offset.applyAxisAngle(camera.getWorldDirection(new THREE.Vector3()).cross(new THREE.Vector3(0, 1, 0)), deltaY * 0.005);

        camera.position.copy(target).add(offset);
        camera.lookAt(target);
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp(e) {
        isMouseDown = false;
    }

    function onWheel(e) {
        e.preventDefault();

        // 1. Find the point to zoom towards (under the cursor)
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // Intersect with the model and the ground plane
        const objectsToIntersect = [];
        if (mesh) objectsToIntersect.push(mesh);
        const ground = scene.getObjectByName("ground_plane");
        if (ground) objectsToIntersect.push(ground);

        const intersects = raycaster.intersectObjects(objectsToIntersect);
        let targetPoint = new THREE.Vector3(0, 10, 0); // Default target
        if (intersects.length > 0) {
            targetPoint = intersects[0].point;
        }

        // 2. Move camera towards that point
        const zoomFactor = e.deltaY > 0 ? 0.1 : -0.1;
        const dir = targetPoint.clone().sub(camera.position).multiplyScalar(zoomFactor);
        camera.position.add(dir);
    }

    function setTopView() {
        const size = parseInt(document.getElementById('size-slider').value);
        camera.position.set(0, size, 0); // Position camera directly above
        camera.lookAt(0, 0, 0);
    }

    function removeImage() {
        originalImage = null;
        
        // Clear the 3D mesh
        if (mesh) {
            scene.remove(mesh);
            mesh = null;
        }

        // Reset UI elements
        document.getElementById('image-preview').style.display = 'none';
        document.getElementById('image-preview').src = '';
        document.getElementById('stats-panel').innerHTML = 'Upload an image to calculate bricks.';
        document.getElementById('file-input').value = ''; // Allows re-uploading the same file
    }

    function handleImageUpload(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                document.getElementById('image-preview').src = img.src;
                document.getElementById('image-preview').style.display = 'block';
                processImage();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Debounce utility to prevent rapid-fire function calls
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }

    function updateSettings() {
        const studs = document.getElementById('size-slider').value;
        document.getElementById('size-val').textContent = studs;
        document.getElementById('depth-val').textContent = document.getElementById('depth-slider').value;

        const cm = (studs * 0.8).toFixed(1);
        const inches = (cm / 2.54).toFixed(1);
        document.getElementById('estimated-size').textContent = `(approx. ${cm}cm / ${inches}")`;

        if(originalImage) debouncedProcessImage();
    }

    function processImage() {
        if(!originalImage) return;
        
        const size = parseInt(document.getElementById('size-slider').value);
        const depthScale = parseInt(document.getElementById('depth-slider').value);
        const contrast = parseFloat(document.getElementById('contrast-slider').value);

        // Canvas processing
        const cv = document.createElement('canvas');
        const aspect = originalImage.height / originalImage.width;
        cv.width = size;
        // The height of the canvas in pixels, which corresponds to the number of rows of bricks.
        cv.height = Math.round(size * aspect);
        const ctx = cv.getContext('2d');
        
        ctx.drawImage(originalImage, 0, 0, cv.width, cv.height);
        const imgData = ctx.getImageData(0, 0, cv.width, cv.height);
        const pixels = imgData.data;

        // 1. Create a height map from the image
        const heightMap = [];
        for (let y = 0; y < cv.height; y++) {
            const row = [];
            for (let x = 0; x < cv.width; x++) {
                const idx = (y * cv.width + x) * 4;
                let r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];

                // Apply contrast
                r = Math.min(255, Math.max(0, (r - 128) * contrast + 128));
                g = Math.min(255, Math.max(0, (g - 128) * contrast + 128));
                b = Math.min(255, Math.max(0, (b - 128) * contrast + 128));

                const colorMatch = findClosestColor(r, g, b);
                const brightness = (r + g + b) / 3;
                const height = 1 + Math.floor((brightness / 255) * depthScale);
                
                row.push({ color: colorMatch, height: height });
            }
            heightMap.push(row);
        }

        // 2. Build bricks from the height map
        buildBricksFromHeightMap(heightMap);
    }

    function buildBricksFromHeightMap(heightMap) {
        if(mesh) scene.remove(mesh);
        mesh = new THREE.Group(); // Use a group instead of InstancedMesh

        // --- Real-world dimensions ---
        const STUD_WIDTH = 0.8; // Corresponds to 0.8 cm
        const STUD_DEPTH = 0.8; // Corresponds to 0.8 cm
        const PLATE_HEIGHT = 0.51; // Corresponds to 0.51 cm

        const height = heightMap.length;
        const width = heightMap[0].length;

        const brickCounts = {};

        // Iterate through each layer of height
        const maxLayer = parseInt(document.getElementById('depth-slider').value) + 1;
        for (let l = 1; l <= maxLayer; l++) {
            // For each row (z-axis) in the current layer
            for (let y = 0; y < height; y++) {
                let x = 0;
                while (x < width) {
                    // Is there a plate here at this layer?
                    if (heightMap[y][x].height < l) {
                        x++;
                        continue;
                    }

                    const color = heightMap[y][x].color;
                    let runLength = 1;

                    // Check for 1x3
                    if (x + 2 < width && heightMap[y][x+1].height >= l && heightMap[y][x+1].color.name === color.name && heightMap[y][x+2].height >= l && heightMap[y][x+2].color.name === color.name) {
                        runLength = 3;
                    } 
                    // Check for 1x2
                    else if (x + 1 < width && heightMap[y][x+1].height >= l && heightMap[y][x+1].color.name === color.name) {
                        runLength = 2;
                    }

                    const brickType = `1x${runLength}`;
                    createBrickMesh(x, l, y, runLength, PLATE_HEIGHT, STUD_WIDTH, STUD_DEPTH, width, height, color.hex);

                    // Update counts
                    if (!brickCounts[color.name]) brickCounts[color.name] = { '1x3': 0, '1x2': 0, '1x1': 0, total: 0 };
                    brickCounts[color.name][brickType]++;
                    brickCounts[color.name].total++;

                    x += runLength;
                }
            }
        }

        scene.add(mesh);
        updateStatsUI(brickCounts);
    }

    function createBrickMesh(x, y, z, studLength, plateHeight, studWidth, studDepth, totalWidth, totalHeight, color) {
        const brickGeo = new THREE.BoxGeometry(studLength * studWidth, plateHeight, studDepth);
        const brickMat = new THREE.MeshStandardMaterial({ color: color });
        const brick = new THREE.Mesh(brickGeo, brickMat);

        // Center the brick based on its run length and position
        const posX = ((x + studLength / 2) - totalWidth / 2) * studWidth;
        const posY = (y * plateHeight) - plateHeight / 2;
        const posZ = (z - totalHeight / 2) * studDepth;

        brick.position.set(posX, posY, posZ);
        brick.castShadow = true;
        brick.receiveShadow = true;
        mesh.add(brick);
    }

    function updateStatsUI(counts) {
        let statsHtml = '';
        let totalBricks = 0;
        const costPerBrick = 0.08; // Average cost
        const partNumbers = { '1x3': '3623', '1x2': '3023', '1x1': '3024' };

        for (const colorName in counts) {
            const c = counts[colorName];
            statsHtml += `<div style="border-left: 4px solid ${findClosestColor(0,0,0,colorName).hex}; padding-left: 8px; margin-bottom: 8px;">`;
            statsHtml += `<b>${colorName}: ${c.total}</b><br>`;
            statsHtml += `<span style="font-size:0.75rem;">1x3 (${partNumbers['1x3']}): ${c['1x3']}, 1x2 (${partNumbers['1x2']}): ${c['1x2']}, 1x1 (${partNumbers['1x1']}): ${c['1x1']}</span>`;
            statsHtml += `</div>`;
            totalBricks += c.total;
        }

        statsHtml += `<hr style="margin: 10px 0;"><b>Total Bricks: ${totalBricks}</b><br>Est Cost: ¬£${(totalBricks * costPerBrick).toFixed(2)}`;
        document.getElementById('stats-panel').innerHTML = statsHtml;
    }

    function findClosestColor(r, g, b, name = null) {
        if (name) return archColors.find(c => c.name === name) || archColors[0];
        let minDiff = Infinity;
        let closest = archColors[0];
        for (let c of archColors) {
            let diff = Math.sqrt(Math.pow(r-c.r,2) + Math.pow(g-c.g,2) + Math.pow(b-c.b,2));
            if (diff < minDiff) { minDiff = diff; closest = c; }
        }
        return closest;
    }

    function generatePDF() {
        const win = window.open('', '_blank');
        win.document.write(`<html><body><h1>Realtor Closing Gift Guide</h1><p>3D Facade Model</p>${document.getElementById('stats-panel').innerHTML}<p>Generated by BlockForge Architect</p></body></html>`);
        win.print();
    }

    window.addEventListener('resize', () => {
        camera.aspect = document.getElementById('canvas-container').clientWidth / document.getElementById('canvas-container').clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(document.getElementById('canvas-container').clientWidth, document.getElementById('canvas-container').clientHeight);
    });

    init();
</script>
</body>
</html>
