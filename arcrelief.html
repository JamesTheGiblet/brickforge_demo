<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockForge Architect - Realty Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Work+Sans:wght@300;600;800&display=swap" rel="stylesheet">
    <style>
        :root { --navy: #0D2B3E; --steel: #1A4D6D; --orange: #FF5722; --white: #FFFFFF; }
        * { box-sizing: border-box; }
        body { font-family: 'Work Sans', sans-serif; background: linear-gradient(135deg, #e0eafc 0%, #cfdef3 100%); color: var(--navy); margin: 0; height: 100vh; display: flex; }
        
        .sidebar { width: 350px; background: white; padding: 2rem; box-shadow: 4px 0 20px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 1.5rem; overflow-y: auto; z-index: 2; }
        .logo { font-family: 'Space Mono', monospace; font-size: 1.5rem; font-weight: 700; color: var(--navy); margin-bottom: 1rem; cursor: pointer; }
        .logo span { color: var(--orange); }
        
        .control-group { margin-bottom: 1rem; }
        label { display: block; font-size: 0.85rem; font-weight: 700; margin-bottom: 0.5rem; color: #666; text-transform: uppercase; }
        input[type="range"] { width: 100%; }
        
        .btn { width: 100%; padding: 12px; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 1rem; transition: 0.2s; margin-top: 5px; }
        .btn-primary { background: var(--orange); color: white; box-shadow: 0 4px 10px rgba(255,87,34,0.3); }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-upload { background: var(--steel); color: white; }
        
        .workspace { flex: 1; position: relative; background: #333; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; }
        
        .stats { background: #f4f4f4; padding: 15px; border-radius: 8px; font-size: 0.85rem; font-family: 'Space Mono', monospace; }
        #image-preview { width: 100%; height: 150px; object-fit: cover; border-radius: 8px; margin-bottom: 10px; display: none; border: 2px solid #eee; }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="logo" onclick="location.href='index.html'">BLOCK<span>FORGE</span></div>
        <div style="font-size: 0.8rem; font-weight: 700; background: #eee; padding: 5px 10px; border-radius: 4px; display: inline-block; margin-bottom: 20px;">ARCHITECT EDITION</div>

        <div class="control-group">
            <label>1. Upload House Photo</label>
            <img id="image-preview">
            <button class="btn btn-upload" onclick="document.getElementById('file-input').click()">üìÅ Select Image</button>
            <input type="file" id="file-input" accept="image/*" style="display: none" onchange="handleImageUpload(this)">
        </div>

        <div class="control-group">
            <label>2. Model Settings</label>
            <div>Size (Baseplate Width): <span id="size-val">48</span> studs</div>
            <input type="range" id="size-slider" min="32" max="96" step="16" value="48" oninput="updateSettings()">
            
            <div style="margin-top:10px;">Relief Depth: <span id="depth-val">15</span> bricks</div>
            <input type="range" id="depth-slider" min="5" max="30" value="15" oninput="updateSettings()">
            
            <div style="margin-top:10px;">Detail/Contrast:</div>
            <input type="range" id="contrast-slider" min="0" max="3" step="0.1" value="1.2" oninput="updateSettings()">
        </div>

        <div class="stats" id="stats-panel">
            Upload an image to calculate bricks.
        </div>

        <button class="btn btn-primary" onclick="generatePDF()">üìÑ Export Realtor Guide</button>
    </div>

    <div class="workspace">
        <div id="canvas-container"></div>
    </div>

<script>
    // --- Architecture Palette (Masonry Focus) ---
    const archColors = [
        { r:255, g:255, b:255, name: 'White', hex: '#FFFFFF' },      // Windows/Trim
        { r:155, g:155, b:155, name: 'Lt Stone', hex: '#9BA19D' },   // Stone
        { r:100, g:100, b:100, name: 'Dk Stone', hex: '#635F52' },   // Roof/Asphalt
        { r:27, g:42, b:52,    name: 'Black', hex: '#1B2A34' },      // Shadows/Depth
        { r:150, g:50, b:50,   name: 'Brick Red', hex: '#8B0000' },  // Bricks
        { r:210, g:180, b:140, name: 'Tan', hex: '#D2B48C' },        // Stucco/Wood
        { r:90, g:70, b:40,    name: 'Dark Tan', hex: '#362313' },   // Timber
        { r:50, g:80, b:50,    name: 'Dk Green', hex: '#237841' }    // Landscaping
    ];

    let scene, camera, renderer, controls, mesh;
    let originalImage = null;

    function init() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 60, 60);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Architectural Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 50, 20);
        sun.castShadow = true;
        scene.add(sun);

        // Ground
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    function handleImageUpload(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                document.getElementById('image-preview').src = img.src;
                document.getElementById('image-preview').style.display = 'block';
                processImage();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function updateSettings() {
        document.getElementById('size-val').textContent = document.getElementById('size-slider').value;
        document.getElementById('depth-val').textContent = document.getElementById('depth-slider').value;
        if(originalImage) processImage();
    }

    function processImage() {
        if(!originalImage) return;
        
        const size = parseInt(document.getElementById('size-slider').value);
        const depthScale = parseInt(document.getElementById('depth-slider').value);
        const contrast = parseFloat(document.getElementById('contrast-slider').value);

        // Canvas processing
        const cv = document.createElement('canvas');
        const aspect = originalImage.height / originalImage.width;
        cv.width = size;
        cv.height = Math.round(size * aspect);
        const ctx = cv.getContext('2d');
        
        ctx.drawImage(originalImage, 0, 0, cv.width, cv.height);
        const imgData = ctx.getImageData(0, 0, cv.width, cv.height);
        const pixels = imgData.data;

        // Build Geometry
        if(mesh) scene.remove(mesh);
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const instancedMesh = new THREE.InstancedMesh(geometry, new THREE.MeshStandardMaterial({ color: 0xffffff }), cv.width * cv.height);
        instancedMesh.castShadow = true;
        instancedMesh.receiveShadow = true;

        let i = 0;
        const dummy = new THREE.Object3D();
        const counts = {};

        for (let y = 0; y < cv.height; y++) {
            for (let x = 0; x < cv.width; x++) {
                const idx = (y * cv.width + x) * 4;
                let r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];

                // Contrast adjust
                r = Math.min(255, Math.max(0, (r - 128) * contrast + 128));
                g = Math.min(255, Math.max(0, (g - 128) * contrast + 128));
                b = Math.min(255, Math.max(0, (b - 128) * contrast + 128));

                // Color Match
                const match = findClosestColor(r, g, b);
                
                // Calculate Height (Brightness)
                const brightness = (r + g + b) / 3;
                // Invert so dark = low (shadows) or light = high? 
                // For architecture: Light usually hits roof/walls. Dark = windows/shadows. 
                // Let's try Standard Relief: Brighter = Higher.
                const h = 1 + Math.floor((brightness / 255) * depthScale);

                // Set Color
                instancedMesh.setColorAt(i, new THREE.Color(match.hex));
                
                // Set Position/Scale
                dummy.position.set(x - cv.width/2, h/2, y - cv.height/2);
                dummy.scale.set(1, h, 1);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);

                // Stats
                counts[match.name] = (counts[match.name] || 0) + h; // Count 1x1 plates equivalent
                i++;
            }
        }

        instancedMesh.instanceMatrix.needsUpdate = true;
        instancedMesh.instanceColor.needsUpdate = true;
        mesh = instancedMesh;
        scene.add(mesh);

        // Update Stats
        let statsHtml = `<b>Estimated Parts:</b><br>`;
        let total = 0;
        let cost = 0;
        for(let c in counts) {
            statsHtml += `${c}: ${counts[c]}<br>`;
            total += counts[c];
            cost += counts[c] * 0.04; // Avg cost per plate
        }
        statsHtml += `<hr><b>Total Plates: ${total}</b><br>Est Cost: ¬£${cost.toFixed(2)}`;
        document.getElementById('stats-panel').innerHTML = statsHtml;
    }

    function findClosestColor(r, g, b) {
        let minDiff = Infinity;
        let closest = archColors[0];
        for (let c of archColors) {
            let diff = Math.sqrt(Math.pow(r-c.r,2) + Math.pow(g-c.g,2) + Math.pow(b-c.b,2));
            if (diff < minDiff) { minDiff = diff; closest = c; }
        }
        return closest;
    }

    function generatePDF() {
        const win = window.open('', '_blank');
        win.document.write(`<html><body><h1>Realtor Closing Gift Guide</h1><p>3D Facade Model</p>${document.getElementById('stats-panel').innerHTML}<p>Generated by BlockForge Architect</p></body></html>`);
        win.print();
    }

    window.addEventListener('resize', () => {
        camera.aspect = document.getElementById('canvas-container').clientWidth / document.getElementById('canvas-container').clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(document.getElementById('canvas-container').clientWidth, document.getElementById('canvas-container').clientHeight);
    });

    init();
</script>
</body>
</html>
