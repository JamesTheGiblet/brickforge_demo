<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>BlockForge - Build. Paint. Create.</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Work+Sans:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --forge-orange: #FF5722;
            --steel-blue: #1A4D6D;
            --navy: #0D2B3E;
            --light-gray: #F5F5F5;
            --white: #FFFFFF;
            --shadow: rgba(13, 43, 62, 0.15);
        }
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Work Sans',sans-serif;background:linear-gradient(135deg,#F5F5F5 0%,#E8EEF2 100%);color:var(--navy);overflow-x:hidden}
        header{background:var(--white);padding:1.5rem 2rem;box-shadow:0 2px 20px var(--shadow);position:sticky;top:0;z-index:100}
        .header-content{max-width:1400px;margin:0 auto;display:flex;justify-content:space-between;align-items:center}
        .logo{display:flex;align-items:center;gap:1rem}
        .logo-icon{width:48px;height:48px;background:linear-gradient(135deg,var(--forge-orange) 0%,#FF7043 100%);border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:bold;color:white;box-shadow:0 4px 12px rgba(255,87,34,0.3)}
        .logo-text{font-family:'Space Mono',monospace;font-size:24px;font-weight:700;color:var(--navy);letter-spacing:-0.5px}
        .logo-text span{color:var(--forge-orange)}
        .header-cta{background:var(--forge-orange);color:white;padding:.875rem 2rem;border:none;border-radius:8px;font-family:'Work Sans',sans-serif;font-size:16px;font-weight:600;cursor:pointer;transition:all .3s ease;box-shadow:0 4px 12px rgba(255,87,34,0.3)}
        .header-cta:hover{background:#FF7043;transform:translateY(-2px);box-shadow:0 6px 20px rgba(255,87,34,0.4)}
        .hero{max-width:1400px;margin:3rem auto;padding:0 2rem;text-align:center}
        .hero h1{font-size:3.5rem;font-weight:800;line-height:1.1;margin-bottom:1rem;background:linear-gradient(135deg,var(--navy) 0%,var(--steel-blue) 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
        .hero .tagline{font-size:1.5rem;color:var(--steel-blue);font-weight:400;margin-bottom:1rem;font-family:'Space Mono',monospace}
        .hero .subtitle{font-size:1.125rem;color:#666;max-width:600px;margin:0 auto 2rem;line-height:1.6}
        .model-selector{display:flex;justify-content:center;gap:1rem;margin-bottom:1rem}
        .model-btn{background:var(--light-gray);border:2px solid #ddd;padding:.75rem 1.5rem;border-radius:8px;font-size:1rem;font-weight:600;cursor:pointer;transition:all .2s}
        .model-btn.active,.model-btn:hover{
            background:var(--forge-orange);
            color:white;
            border-color:var(--forge-orange);
            transform:translateY(-2px)
        }
        .container{max-width:1400px;margin:0 auto;padding:0 2rem 4rem}
        .workspace{display:grid;grid-template-columns:1fr 380px;gap:2rem;margin-top:2rem}
        .viewer-container{background:white;border-radius:16px;padding:2rem;box-shadow:0 4px 24px var(--shadow);position:relative}
        .viewer-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem}
        .viewer-header h2{font-size:1.5rem;font-weight:700;color:var(--navy)}
        .view-controls{display:flex;gap:.5rem}
        .control-btn{background:var(--light-gray);border:none;width:36px;height:36px;border-radius:6px;cursor:pointer;font-size:18px;transition:all .2s;display:flex;align-items:center;justify-content:center}
        .control-label{display:flex;align-items:center;gap:5px;margin-left:10px;font-size:14px;cursor:pointer;color:var(--steel-blue)}
        .control-label input{cursor:pointer}
        .control-btn:hover{background:var(--steel-blue);color:white}
        #canvas-container{width:100%;height:600px;background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);border-radius:12px;position:relative;overflow:hidden}
        .canvas-hint{position:absolute;bottom:1rem;left:50%;transform:translateX(-50%);background:rgba(13,43,62,0.9);color:white;padding:.75rem 1.5rem;border-radius:8px;font-size:.875rem;font-family:'Space Mono',monospace;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}
        .layer-control-container{position:absolute;right:1rem;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;align-items:center;gap:10px;background:rgba(255,255,255,0.8);padding:15px 10px;border-radius:10px;-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px);box-shadow:0 2px 10px rgba(0,0,0,0.1)}
        #layer-label{font-family:'Space Mono',monospace;font-size:12px;font-weight:bold;color:var(--navy)}
        #layer-slider{
            -webkit-appearance: none; /* Remove default styling */
            appearance: none;
            writing-mode: vertical-lr;
            direction: rtl;
            width:8px;
            height:200px;
            cursor:pointer
        }
        #layer-slider::-webkit-slider-thumb{width:20px;height:20px;border-radius:50%;background:var(--forge-orange);border:2px solid white;box-shadow:0 0 5px rgba(0,0,0,0.2)}
        #layer-slider::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:var(--forge-orange);border:2px solid white;box-shadow:0 0 5px rgba(0,0,0,0.2)}
        #layer-slider::-moz-range-track{background:var(--light-gray);border-radius:4px}
        #layer-slider::-webkit-slider-runnable-track{background:var(--light-gray);border-radius:4px}
        .sidebar{display:flex;flex-direction:column;gap:1.5rem}
        .panel{background:white;border-radius:16px;padding:1.5rem;box-shadow:0 4px 24px var(--shadow)}
        .panel h3{font-size:1.25rem;font-weight:700;margin-bottom:1rem;color:var(--navy);display:flex;align-items:center;gap:.5rem}
        .panel h3::before{content:'';width:4px;height:24px;background:var(--forge-orange);border-radius:2px}
        .color-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem}
        .color-btn{aspect-ratio:1;border:3px solid transparent;border-radius:12px;cursor:pointer;transition:all .3s ease;position:relative;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
        .color-btn:hover{transform:scale(1.1);box-shadow:0 4px 16px rgba(0,0,0,0.2)}
        .color-btn.active{border-color:var(--navy);transform:scale(1.05)}
        .color-btn.active::after{content:'‚úì';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;font-size:20px;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.3)}
        .color-btn[data-name="White"].active::after{color:black;text-shadow:none;}
        .block-list{display:flex;flex-direction:column;gap:.75rem}
        .block-item{background:var(--light-gray);padding:1rem;border-radius:10px;border-left:4px solid}
        .block-item-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem}
        .block-color{font-weight:600;font-size:1rem}
        .block-total{font-family:'Space Mono',monospace;font-weight:700;font-size:1.125rem}
        .block-breakdown{display:flex;gap:1rem;font-size:.875rem;color:#666;font-family:'Space Mono',monospace}
        .total-summary{background:linear-gradient(135deg,var(--navy) 0%,var(--steel-blue) 100%);color:white;padding:1.5rem;border-radius:12px;margin-top:1rem}
        .total-summary .label{font-size:.875rem;opacity:.9;margin-bottom:.25rem}
        .total-summary .value{font-size:2rem;font-weight:700;font-family:'Space Mono',monospace;line-height:1}
        .price-display{text-align:center;padding:2rem;background:linear-gradient(135deg,#FFF3E0 0%,#FFE0B2 100%);border-radius:12px;margin-bottom:1rem}
        .details-grid{display:grid;grid-template-columns:auto 1fr;gap:.5rem 1rem;font-size:.875rem;align-items:center}
        .details-grid .label{font-weight:600;color:#666}
        .details-grid .value{font-family:'Space Mono',monospace;background:var(--light-gray);padding:.25rem .5rem;border-radius:4px}
        #details-panel{display:none}
        #details-panel.active{display:block}
        .total-header{display:flex;justify-content:space-between;align-items:center}
        .total-breakdown{font-family:'Space Mono',monospace;font-size:.875rem;text-align:right;opacity:.9}
        .total-breakdown div{margin-bottom:2px}
        .price-label{font-size:.875rem;color:#666;margin-bottom:.5rem;font-weight:600;text-transform:uppercase;letter-spacing:1px}
        .price-value{font-size:3rem;font-weight:800;color:var(--forge-orange);font-family:'Space Mono',monospace;line-height:1}
        .price-note{font-size:.75rem;color:#666;margin-top:.5rem}
        .forge-button{width:100%;background:linear-gradient(135deg,var(--forge-orange) 0%,#FF7043 100%);color:white;padding:1.25rem;border:none;border-radius:12px;font-size:1.125rem;font-weight:700;cursor:pointer;transition:all .3s ease;box-shadow:0 6px 20px rgba(255,87,34,0.4);text-transform:uppercase;letter-spacing:1px}
        .forge-button:hover{transform:translateY(-2px);box-shadow:0 8px 30px rgba(255,87,34,0.5)}
        .forge-button:active{transform:translateY(0)}
        .features{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-top:1rem}
        .feature{text-align:center;padding:1rem}
        .feature-icon{font-size:2rem;margin-bottom:.5rem}
        .feature-text{font-size:.875rem;color:#666;line-height:1.4}
        .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:1000;align-items:center;justify-content:center}
        .modal.active{display:flex}
        .modal-content{background:white;border-radius:20px;padding:3rem;max-width:600px;text-align:center;position:relative;animation:modalSlideIn .3s ease}
        @keyframes modalSlideIn{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}
        .modal-close{position:absolute;top:1rem;right:1rem;background:none;border:none;font-size:2rem;cursor:pointer;color:#999;width:40px;height:40px;display:flex;align-items:center;justify-content:center;border-radius:50%;transition:all .2s}
        .modal-close:hover{background:var(--light-gray);color:var(--navy)}
        .modal h2{font-size:2rem;margin-bottom:1rem;color:var(--navy)}
        .modal p{font-size:1.125rem;color:#666;line-height:1.6;margin-bottom:2rem}
        .success-icon{font-size:4rem;color:var(--forge-orange);margin-bottom:1rem}
        @media (max-width:968px){.workspace{grid-template-columns:1fr}.hero h1{font-size:2.5rem}#canvas-container{height:400px}}
        .modal.generating{background:rgba(245,245,245,0.8);-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px)}
        #instructions-loading{display:none; margin-top:1rem; font-family:'Space Mono',monospace; color: var(--steel-blue);}
        .loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center}
        .spinner{width:50px;height:50px;border:4px solid var(--light-gray);border-top-color:var(--forge-orange);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 1rem}
        @keyframes spin{to{transform:rotate(360deg)}}
    </style>
</head>
<body>
<!-- Header -->
<header>
    <div class="header-content">
        <div class="logo">
            <div class="logo-icon">üî®</div>
            <div class="logo-text">BLOCK<span>FORGE</span></div>
        </div>
        <button class="header-cta" onclick="showInstructions()">View Instructions</button>
    </div>
</header>

<!-- Hero -->
<section class="hero">
    <h1>Design Your Custom Model</h1>
    <div class="model-selector">
        <button class="model-btn active" data-model="bear" onclick="switchModel('bear')">üß∏ Bear</button>
        <button class="model-btn" data-model="penguin" onclick="switchModel('penguin')">üêß Penguin</button>
    </div>
    <p class="tagline">Build. Paint. Create.</p>    
    <p class="subtitle">Click any block to change its color. Create a one-of-a-kind building block masterpiece.</p>
</section>

<!-- Main Workspace -->
<div class="container">
    <div class="workspace">
        <!-- 3D Viewer -->
        <div class="viewer-container">
            <div class="viewer-header">
                <h2>3D Designer</h2>
                <div class="view-controls">
                    <button class="control-btn" onclick="resetCamera()" title="Reset View">‚ü≤</button>
                    <button class="control-btn" onclick="exportImage('front')" title="Export Front">‚¨áÔ∏è Front</button>
                    <button class="control-btn" onclick="exportImage('back')" title="Export Back">‚¨áÔ∏è Back</button>
                    <button class="control-btn" onclick="exportImage('side')" title="Export Side">‚¨áÔ∏è Side</button>
                    <label class="control-label">
                        <input type="checkbox" id="invert-y-checkbox" onchange="toggleInvertControls(this.checked)"> Invert Y
                    </label>
                </div>
            </div>
            <div id="canvas-container">
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Loading 3D Model...</div>
                </div>
                <div class="canvas-hint">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click bricks to paint</div>
                <div class="layer-control-container">
                    <label id="layer-label" for="layer-slider">Layer: All</label>
                    <input type="range" id="layer-slider" min="0" max="65" step="1" value="65">
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Color Palette -->
            <div class="panel">
                <h3>Color Palette</h3>
                <div class="color-grid">
                    <button class="color-btn active" style="background-color: #E53935;" data-color="#E53935" data-name="Red" title="Red"></button>
                    <button class="color-btn" style="background-color: #1E88E5;" data-color="#1E88E5" data-name="Blue" title="Blue"></button>
                    <button class="color-btn" style="background-color: #FDD835;" data-color="#FDD835" data-name="Yellow" title="Yellow"></button>
                    <button class="color-btn" style="background-color: #43A047;" data-color="#43A047" data-name="Green" title="Green"></button>
                    <button class="color-btn" style="background-color: #FB8C00;" data-color="#FB8C00" data-name="Orange" title="Orange"></button>
                    <button class="color-btn" style="background-color: #FFFFFF; border: 2px solid #E0E0E0;" data-color="#FFFFFF" data-name="White" title="White"></button>
                    <button class="color-btn" style="background-color: #8B0000;" data-color="#8B0000" data-name="DarkRed" title="DarkRed"></button>
                    <button class="color-btn" style="background-color: #808080;" data-color="#808080" data-name="Gray" title="Gray"></button>
                </div>
            </div>

            <!-- Brick Details -->
            <div class="panel" id="details-panel">
                <h3>Brick Details</h3>
                <div class="details-grid">
                    <div class="label">Type:</div><div class="value" id="detail-type">-</div>
                    <div class="label">Color:</div><div class="value" id="detail-color">-</div>
                    <div class="label">Position:</div><div class="value" id="detail-position">-</div>
                </div>
            </div>



            <!-- Block Counter -->
            <div class="panel">
                <h3>Parts List</h3>
                <div class="block-list" id="block-list"><!-- populated --></div>
                <div class="total-summary">
                    <div class="total-header">
                        <div class="total-main">
                            <div class="label">Total Pieces</div>
                            <div class="value" id="total-pieces">0</div>
                        </div>
                        <div class="total-breakdown">
                            <div id="total-1x3">1x3: 0</div><div id="total-1x2">1x2: 0</div><div id="total-1x1">1x1: 0</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pricing & CTA -->
            <div class="panel">
                <div class="price-display">
                    <div class="price-label">Your Custom Bear</div>
                    <div class="price-value" id="price-value">$0.00</div>
                    <div class="price-note">Includes shipping & instructions</div>
                </div>
                <button class="forge-button" onclick="checkout()">üî® Forge Your Design</button>

                <div class="features">
                    <div class="feature"><div class="feature-icon">üì¶</div><div class="feature-text">Ships in 3-5 days</div></div>
                    <div class="feature"><div class="feature-icon">üìÑ</div><div class="feature-text">Instant PDF instructions</div></div>
                    <div class="feature"><div class="feature-icon">üß±</div><div class="feature-text">Premium quality blocks</div></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal" id="modal">
    <div class="modal-content">
        <button class="modal-close" onclick="closeModal()">√ó</button>
        <div class="success-icon">üìÑ</div>
        <h2>Build Instructions</h2>
        <p>Generate a printable, step-by-step guide for your unique creation. Each page will show the parts needed and a snapshot of the build at that layer.</p>
        <button class="forge-button" onclick="generateInstructions()">Download Demo</button>
        <div id="instructions-loading">Generating... Please wait.</div>
    </div>
</div>

<script>
/* ---------- Global state & geometry constants ---------- */
let scene, camera, renderer, bear;
let selectedColor = '#E53935', selectedColorName = 'Red';
let isDragging = false, isMouseDown = false, previousMousePosition = {x:0,y:0};
let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
let voxelGrid = {}; // key "x,y,z" -> {x,y,z,colorName}
let blockCounts = {}; // colorName -> {color, '1x3', '1x2', '1x1', total}
let invertY = false;
let selectionOutline, selectedBrick = null;
let currentModel = 'bear';
let originalCameraPosition = null;

// Voxel / brick sizing (grid units -> world units)
const voxelUnit = 0.48; // footprint of a single voxel in X/Z
const voxelHeight = 0.58; // height of a single voxel
// When building bricks, lengths along X are multiplied by voxelUnit for geometry

// Pricing constants
const PART_COSTS = {
    '1x1': 0.02,
    '1x2': 0.03,
    '1x3': 0.04,
};

// Color name to hex map
function getHexForColorName(name){
    const map = { Red:'#E53935', Blue:'#1E88E5', Yellow:'#FDD835', Green:'#43A047', Orange:'#FB8C00', White:'#FFFFFF', DarkRed:'#8B0000', Gray:'#808080' };
    return map[name] || '#8B0000';
}

// Utility to store voxel in integer grid coordinates
function storeVoxel(ix, iy, iz, colorName){
    const key = `${ix},${iy},${iz}`;
    voxelGrid[key] = { x: ix, y: iy, z: iz, colorName };
}

/* ---------- Build the voxel bear (store voxels, do NOT add tiny cubes to scene) ---------- */
function createBear(){
    // Clear previous voxel grid and group
    voxelGrid = {};
    if (bear) scene.remove(bear);
    bear = new THREE.Group();

    // We'll use integer grid coordinates for voxels
    // The original numeric ranges are preserved but we'll treat those numbers as grid coordinates.
    // FEET - Rounded and protruding forward
    const footCenters = [{x:-6, y:2, z:0}, {x:6, y:2, z:0}];
    const footRadius = 3.5;
    const footThickness = 1.5;

    footCenters.forEach(center => {
        for (let y = 0; y < 6; y++) {
            for (let x = Math.floor(center.x - footRadius); x <= Math.ceil(center.x + footRadius); x++) {
                for (let z = Math.floor(center.z - footRadius); z <= Math.ceil(center.z + footRadius); z++) {
                    if (onSphereSurface(x, y, z, center.x, center.y, center.z, footRadius, footThickness)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
    });

    // TOES & CLAWS - 3 distinct orbs per foot with claws
    const toeDefs = [
        { cx: -7.5, cy: 1.5, cz: 4.5, clawZ: 6 }, { cx: -6, cy: 1.5, cz: 5, clawZ: 7 }, { cx: -4.5, cy: 1.5, cz: 4.5, clawZ: 6 }, // Left
        { cx: 4.5, cy: 1.5, cz: 4.5, clawZ: 6 },  { cx: 6, cy: 1.5, cz: 5, clawZ: 7 },  { cx: 7.5, cy: 1.5, cz: 4.5, clawZ: 6 }  // Right
    ];
    const toeRadius = 1.5; // This radius means the orb is 3 units tall
    const toeThickness = 1.2;

    toeDefs.forEach(toe => {
        // Create the toe orb
        for (let y = Math.floor(toe.cy - toeRadius); y <= Math.ceil(toe.cy + toeRadius); y++) {
            for (let x = Math.floor(toe.cx - toeRadius); x <= Math.ceil(toe.cx + toeRadius); x++) {
                for (let z = Math.floor(toe.cz - toeRadius); z <= Math.ceil(toe.cz + toeRadius); z++) {
                    if (onSphereSurface(x, y, z, toe.cx, toe.cy, toe.cz, toeRadius, toeThickness)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
        // Add the white claw at the tip
        storeVoxel(Math.round(toe.cx), 1, toe.clawZ, 'White');
    });

    // LEGS - composed of two ovals for a more organic shape
    const legCenters = [
        { thigh: {cx:-6, cy:14, cz:-1, rx:2.5, ry:6, rz:2}, calf: {cx:-6, cy:8, cz:-1, rx:2.2, ry:5, rz:1.8} }, // Left
        { thigh: {cx:6, cy:14, cz:-1, rx:2.5, ry:6, rz:2}, calf: {cx:6, cy:8, cz:-1, rx:2.2, ry:5, rz:1.8} }  // Right
    ];

    legCenters.forEach(leg => {
        // Thigh (upper leg)
        for (let y = 10; y < 20; y++) {
            for (let x = Math.floor(leg.thigh.cx - leg.thigh.rx); x <= Math.ceil(leg.thigh.cx + leg.thigh.rx); x++) {
                for (let z = Math.floor(leg.thigh.cz - leg.thigh.rz); z <= Math.ceil(leg.thigh.cz + leg.thigh.rz); z++) {
                    if (onEllipsoidSurface(x, y, z, leg.thigh.cx, leg.thigh.cy, leg.thigh.cz, leg.thigh.rx, leg.thigh.ry, leg.thigh.rz, 1.0)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
        // Calf (lower leg)
        for (let y = 5; y < 14; y++) {
            for (let x = Math.floor(leg.calf.cx - leg.calf.rx); x <= Math.ceil(leg.calf.cx + leg.calf.rx); x++) {
                for (let z = Math.floor(leg.calf.cz - leg.calf.rz); z <= Math.ceil(leg.calf.cz + leg.calf.rz); z++) {
                    if (onEllipsoidSurface(x, y, z, leg.calf.cx, leg.calf.cy, leg.calf.cz, leg.calf.rx, leg.calf.ry, leg.calf.rz, 1.0)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
    });

    // BODY (17-38)
    for (let y = 17; y < 39; y++){
        for (let x = -8; x <= 8; x++){
            for (let z = -6; z <= 6; z++){
                if (onEllipsoidSurface(x, y, z, 0, 27, 0, 7, 12, 6, 1.5)){
                    storeVoxel(x, y, z, 'Red');
                }
            }
        }
    }

    // TAIL - small and round
    const tailCenter = {x: 0, y: 22, z: -7};
    const tailRadius = 2.5;
    const tailThickness = 1.5;
    for (let y = Math.floor(tailCenter.y - tailRadius); y <= Math.ceil(tailCenter.y + tailRadius); y++) {
        for (let x = Math.floor(tailCenter.x - tailRadius); x <= Math.ceil(tailCenter.x + tailRadius); x++) {
            for (let z = Math.floor(tailCenter.z - tailRadius); z <= Math.ceil(tailCenter.z + tailRadius); z++) {
                if (onSphereSurface(x, y, z, tailCenter.x, tailCenter.y, tailCenter.z, tailRadius, tailThickness)) {
                    storeVoxel(x, y, z, 'Red');
                }
            }
        }
    }

    // BELLY (yellow patch)
    for (let y = 20; y < 35; y++){
        for (let x = -4; x <= 4; x++){
            for (let z = 4; z <= 6; z++){
                if (onEllipsoidSurface(x, y, z, 0, 27, 5, 4.5, 11, 2, 1.2)){
                    storeVoxel(x, y, z, 'Yellow');
                }
            }
        }
    }

    // ARMS - composed of two ovals for a more organic shape
    const armCenters = [
        { shoulder: {cx:-8.5, cy:30, cz:0, rx:3, ry:5, rz:2.5}, forearm: {cx:-9.5, cy:24, cz:0, rx:2.5, ry:6, rz:2} }, // Left
        { shoulder: {cx:8.5, cy:30, cz:0, rx:3, ry:5, rz:2.5}, forearm: {cx:9.5, cy:24, cz:0, rx:2.5, ry:6, rz:2} }  // Right
    ];

    armCenters.forEach(arm => {
        // Shoulder (upper arm)
        for (let y = 25; y < 36; y++) {
            for (let x = Math.floor(arm.shoulder.cx - arm.shoulder.rx); x <= Math.ceil(arm.shoulder.cx + arm.shoulder.rx); x++) {
                for (let z = Math.floor(arm.shoulder.cz - arm.shoulder.rz); z <= Math.ceil(arm.shoulder.cz + arm.shoulder.rz); z++) {
                    if (onEllipsoidSurface(x, y, z, arm.shoulder.cx, arm.shoulder.cy, arm.shoulder.cz, arm.shoulder.rx, arm.shoulder.ry, arm.shoulder.rz, 1.0)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
        // Forearm (lower arm)
        for (let y = 18; y < 31; y++) {
            for (let x = Math.floor(arm.forearm.cx - arm.forearm.rx); x <= Math.ceil(arm.forearm.cx + arm.forearm.rx); x++) {
                for (let z = Math.floor(arm.forearm.cz - arm.forearm.rz); z <= Math.ceil(arm.forearm.cz + arm.forearm.rz); z++) {
                    if (onEllipsoidSurface(x, y, z, arm.forearm.cx, arm.forearm.cy, arm.forearm.cz, arm.forearm.rx, arm.forearm.ry, arm.forearm.rz, 1.0)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
    });

    // FINGERS & CLAWS - 3 distinct orbs per hand with claws
    const fingerDefs = [
        { cx: -11.5, cy: 19, cz: 1.5, clawZ: 3 }, { cx: -10, cy: 19, cz: 2, clawZ: 4 }, { cx: -8.5, cy: 19, cz: 1.5, clawZ: 3 }, // Left
        { cx: 8.5, cy: 19, cz: 1.5, clawZ: 3 },  { cx: 10, cy: 19, cz: 2, clawZ: 4 },  { cx: 11.5, cy: 19, cz: 1.5, clawZ: 3 }  // Right
    ];
    const fingerRadius = 1.5;
    const fingerThickness = 1.2;

    fingerDefs.forEach(finger => {
        // Create the finger orb
        for (let y = Math.floor(finger.cy - fingerRadius); y <= Math.ceil(finger.cy + fingerRadius); y++) {
            for (let x = Math.floor(finger.cx - fingerRadius); x <= Math.ceil(finger.cx + fingerRadius); x++) {
                for (let z = Math.floor(finger.cz - fingerRadius); z <= Math.ceil(finger.cz + fingerRadius); z++) {
                    if (onSphereSurface(x, y, z, finger.cx, finger.cy, finger.cz, fingerRadius, fingerThickness)) storeVoxel(x, y, z, 'Red');
                }
            }
        }
        // Add the white claw at the tip
        storeVoxel(Math.round(finger.cx), Math.round(finger.cy), finger.clawZ, 'White');
    });

    // NECK
    for (let y = 39; y < 43; y++){
        for (let x = -4; x <= 4; x++){
            for (let z = -4; z <= 4; z++){
                if (onSphereSurface(x, y, z, 0, 40, 0, 3.5, 1.0)){
                    storeVoxel(x, y, z, 'Red');
                }
            }
        }
    }

    // HEAD
    for (let y = 43; y < 61; y++){
        for (let x = -9; x <= 9; x++){
            for (let z = -6; z <= 6; z++){
                if (onEllipsoidSurface(x, y, z, 0, 51, 0, 9, 8, 7, 1.5)){
                    storeVoxel(x, y, z, 'Red');
                }
            }
        }
    }

    // SNOUT
    for (let y = 48; y < 55; y++){
        for (let x = -3; x <= 3; x++){
            for (let z = 6; z <= 10; z++){
                if (onEllipsoidSurface(x, y, z, 0, 51, 8, 3, 3, 2.5, 1.2)){
                    storeVoxel(x, y, z, 'Red');
                }
            }
        }
    }

    // EARS
    // EARS - Solid back with indented front
    const earCenters = [{x:-7, y:61, z:0}, {x:7, y:61, z:0}];
    const earRadius = 4.0;
    const earIndentRadius = 3.0;

    earCenters.forEach(center => {
        for (let y = center.y - earRadius; y <= center.y + earRadius; y++) {
            for (let x = center.x - earRadius; x <= center.x + earRadius; x++) {
                for (let z = center.z - earRadius; z <= center.z + earRadius; z++) {
                    const dist = Math.sqrt((x-center.x)**2 + (y-center.y)**2 + (z-center.z)**2);
                    // Is it part of the main ear sphere?
                    if (dist <= earRadius) {
                        // Is it NOT part of the front-facing indent?
                        if (dist > earIndentRadius || z < center.z) {
                            storeVoxel(Math.round(x), Math.round(y), Math.round(z), 'Red');
                        }
                    }
                }
            }
        }
    });

    // EYES (white) - small patches
    for (let y = 52; y < 57; y++){
        for (let x = -5; x <= -2; x++){
            for (let z = 4; z <= 7; z++){
                if (onSphereSurface(x, y, z, -3.5, 54, 5.5, 2.0, 0.8)){
                    storeVoxel(x, y, z, 'White');
                }
            }
        }
        for (let x = 2; x <= 5; x++){
            for (let z = 4; z <= 7; z++){
                if (onSphereSurface(x, y, z, 3.5, 54, 5.5, 2.0, 0.8)){
                    storeVoxel(x, y, z, 'White');
                }
            }
        }
    }

    // Eye pupils
    storeVoxel(-4, 54, 7, 'Blue');
    storeVoxel(4, 54, 7, 'Blue');

    // Nose (blue) - rounded
    const noseCenter = {x: 0, y: 51, z: 11};
    const noseRadius = 1.5;
    const noseThickness = 1.2;
    for (let y = Math.floor(noseCenter.y - noseRadius); y <= Math.ceil(noseCenter.y + noseRadius); y++) {
        for (let x = Math.floor(noseCenter.x - noseRadius); x <= Math.ceil(noseCenter.x + noseRadius); x++) {
            for (let z = Math.floor(noseCenter.z - noseRadius); z <= Math.ceil(noseCenter.z + noseRadius); z++) {
                if (onSphereSurface(x, y, z, noseCenter.x, noseCenter.y, noseCenter.z, noseRadius, noseThickness)) storeVoxel(x, y, z, 'Blue');
            }
        }
    }

    // Smile
    for (let x = -3; x <= 3; x++){
        const z = 9;
        const y = Math.round(48 - Math.abs(x) * 0.5);
        storeVoxel(x, y, z, 'Blue');
    }

    // JAW
    for (let y = 45; y < 48; y++){
        for (let x = -3; x <= 3; x++){
            for (let z = 6; z <= 9; z++){
                if (onEllipsoidSurface(x, y, z, 0, 46, 7.5, 3, 1.5, 1.5, 1.0)){
                    storeVoxel(x, y, z, 'Red');
                }
            }
        }
    }

    // BOW TIE - classic bow shape
    const bowTieY = 40;
    const bowTieZ = 5;
    // Knot
    storeVoxel(0, bowTieY, bowTieZ, 'Blue');
    storeVoxel(0, bowTieY, bowTieZ - 1, 'Blue');
    // Left Wing
    storeVoxel(-1, bowTieY, bowTieZ, 'Blue'); // Pinch
    storeVoxel(-2, bowTieY + 1, bowTieZ, 'Blue'); storeVoxel(-3, bowTieY + 1, bowTieZ, 'Blue'); // Top flare
    storeVoxel(-2, bowTieY - 1, bowTieZ, 'Blue'); storeVoxel(-3, bowTieY - 1, bowTieZ, 'Blue'); // Bottom flare
    // Right Wing
    storeVoxel(1, bowTieY, bowTieZ, 'Blue');  // Pinch
    storeVoxel(2, bowTieY + 1, bowTieZ, 'Blue');  storeVoxel(3, bowTieY + 1, bowTieZ, 'Blue');  // Top flare
    storeVoxel(2, bowTieY - 1, bowTieZ, 'Blue');  storeVoxel(3, bowTieY - 1, bowTieZ, 'Blue');  // Bottom flare

    // After storing voxels, build bricks
    buildBricksFromVoxels();
}

function createPenguin(){
    // Clear previous voxel grid and group
    voxelGrid = {};
    if (typeof bear !== 'undefined' && bear) scene.remove(bear);
    bear = new THREE.Group(); // Kept 'bear' name for compatibility with your setup

    // Body - Procedurally generated for a fatter base and more rounded shape
    const bodyMinY = 0, bodyMaxY = 20;
    for (let y = bodyMinY; y < bodyMaxY; y++) {
        const progress = (y - bodyMinY) / (bodyMaxY - bodyMinY); // 0 at bottom, 1 at top
        
        // Use a sine curve to create a more natural, egg-like shape
        const curve = Math.sin(progress * Math.PI); // 0 at bottom, 1 in middle, 0 at top
        const rx = 3.0 + curve * 2.5; // Radius X: starts at 3, swells to 5.5, ends at 3
        const rz = 2.5 + curve * 2.5; // Radius Z: starts at 2.5, swells to 5, ends at 2.5

        for (let x = -Math.ceil(rx); x <= Math.ceil(rx); x++) {
            for (let z = -Math.ceil(rz); z <= Math.ceil(rz); z++) {
                if ((x / rx) ** 2 + (z / rz) ** 2 <= 1) {
                    const isBelly = z > rz * 0.4 && Math.abs(x) < rx * 0.6;
                    storeVoxel(x, y, z, isBelly ? 'White' : 'Gray');
                }
            }
        }
    }

    // Head
    const headCenter = { x: 0, y: 23, z: 0 };
    const headRadius = 3.5;
    for (let y = Math.floor(headCenter.y - headRadius); y <= Math.ceil(headCenter.y + headRadius); y++) {
        for (let x = Math.floor(headCenter.x - headRadius); x <= Math.ceil(headCenter.x + headRadius); x++) {
            for (let z = Math.floor(headCenter.z - headRadius); z <= Math.ceil(headCenter.z + headRadius); z++) {
                if ((x - headCenter.x) ** 2 + (y - headCenter.y) ** 2 + (z - headCenter.z) ** 2 <= headRadius ** 2) {
                    storeVoxel(x, y, z, 'Gray');
                }
            }
        }
    }
    // Beak
    storeVoxel(0, 23, 3, 'Orange');
    storeVoxel(0, 22, 3, 'Orange');
    storeVoxel(0, 23, 4, 'Orange');
    // Eyes
    storeVoxel(-1, 24, 3, 'White');
    storeVoxel(1, 24, 3, 'White');
    
    // Feet
    for (let x = -3; x <= -1; x++) {
        for (let z = 3; z <= 5; z++) {
            storeVoxel(x, 0, z, 'Orange'); // Left foot
        }
    }
    for (let x = 1; x <= 3; x++) {
        for (let z = 3; z <= 5; z++) {
            storeVoxel(x, 0, z, 'Orange'); // Right foot
        }
    }

    // Wings
    const wingCenterY = 12;
    const wingRy = 6;
    [-1, 1].forEach(side => {
        const wingCx = (4.8) * side;
        const wingMinY = wingCenterY - wingRy;
        const wingMaxY = wingCenterY + wingRy;

        for (let y = wingMinY; y <= wingMaxY; y++) {
            const progress = (y - wingMinY) / (wingMaxY - wingMinY); // 0 at bottom, 1 at top
            const taper = 1 - progress; // Inverted progress
            const currentRx = 0.5 + (1.0 * taper); // Tapers from 1.5 down to 0.5
            const currentRz = 1.0 + (1.5 * taper); // Tapers from 2.5 down to 1.0
            for (let x = Math.floor(wingCx - currentRx); x <= Math.ceil(wingCx + currentRx); x++) {
                for (let z = -Math.ceil(currentRz) - 1; z <= Math.ceil(currentRz) - 1; z++) {
                    if (((x - wingCx) / currentRx) ** 2 + ((z + 1) / currentRz) ** 2 <= 1) {
                        storeVoxel(x, y, z, 'Gray');
                    }
                }
            }
        }
    });

    // After storing voxels, build bricks
    buildBricksFromVoxels();
}

/* ---------- Brick builder: per-layer horizontal grouping along X ---------- */
function buildBricksFromVoxels(){
    // Clear previous bear group and counts
    if (bear) scene.remove(bear);
    bear = new THREE.Group();
    blockCounts = {}; // reset counts

    // Organize voxels by layer (y) then by row (z)
    const layers = {}; // y -> { z -> [voxels sorted by x] }
    Object.values(voxelGrid).forEach(v=>{
        if (!layers[v.y]) layers[v.y] = {};
        if (!layers[v.y][v.z]) layers[v.y][v.z] = [];
        layers[v.y][v.z].push(v);
    });

    const bricks = []; // each brick: {voxels:[], colorName, type}

    // For each layer and each row (z), sort voxels by x and find runs
    Object.keys(layers).map(Number).sort((a,b)=>a-b).forEach(y=>{
        const rows = layers[y];
        Object.keys(rows).map(Number).sort((a,b)=>a-b).forEach(z=>{
            const row = rows[z].sort((a,b)=>a.x - b.x);
            if (row.length === 0) return;

            let run = [row[0]];
            for (let i=1;i<row.length;i++){
                const prev = row[i-1], curr = row[i];
                // Adjacent on X (distance 1) and same color -> continue run
                if (curr.x === prev.x + 1 && curr.colorName === prev.colorName){
                    run.push(curr);
                } else {
                    finalizeRun(run);
                    run = [curr];
                }
            }
            finalizeRun(run);
        });
    });

    // finalizeRun helper
    function finalizeRun(run){
        if (!run || run.length === 0) return;
        // Split longer runs into 3/2/1 segments preferring 3, then 2, then 1
        let i = 0;
        while (i < run.length){
            const remaining = run.length - i;
            if (remaining >= 3){
                bricks.push({ voxels: run.slice(i, i+3), colorName: run[i].colorName, type: '1x3' });
                i += 3;
            } else if (remaining === 2){
                bricks.push({ voxels: run.slice(i, i+2), colorName: run[i].colorName, type: '1x2' });
                i += 2;
            } else { // remaining === 1
                bricks.push({ voxels: [run[i]], colorName: run[i].colorName, type: '1x1' });
                i += 1;
            }
        }
    }

    // Create mesh for each brick
    bricks.forEach(br=>{
        createBrickMesh(br.voxels, br.type, br.colorName);
        // Update counts
        if (!blockCounts[br.colorName]) blockCounts[br.colorName] = { color: getHexForColorName(br.colorName), '1x3':0,'1x2':0,'1x1':0, total:0 };
        blockCounts[br.colorName][br.type]++;
        blockCounts[br.colorName].total++;
    });

    // Add group to scene
    scene.add(bear);

    // Populate UI
    renderBlockCountUI();
}
function updateLayerVisibility(targetLayer) {
    if (!bear) return;
    bear.children.forEach(brick => brick.visible = (brick.userData.voxels[0].y <= targetLayer));
}

/* ---------- Create a single brick mesh from voxel run (centered) ---------- */
function createBrickMesh(voxels, type, colorName){
    const len = voxels.length; // 1,2,3
    // World dimensions
    const width = voxelUnit * len; // X dimension
    const height = voxelHeight;    // Y dimension
    const depth = voxelUnit;       // Z dimension

    // The brick is now a group containing the base and studs
    const brickGroup = new THREE.Group();

    const material = new THREE.MeshStandardMaterial({ color: getHexForColorName(colorName), roughness:0.4, metalness:0.05 });

    // 1. Create the base box
    const baseGeom = new THREE.BoxGeometry(width, height, depth);
    const baseMesh = new THREE.Mesh(baseGeom, material);
    baseMesh.castShadow = true;
    baseMesh.receiveShadow = true;
    brickGroup.add(baseMesh);

    // 2. Create and add studs on top
    const studRadius = voxelUnit * 0.25;
    const studHeight = voxelHeight * 0.2;
    const studGeom = new THREE.CylinderGeometry(studRadius, studRadius, studHeight, 16);

    for (let i = 0; i < len; i++) {
        const stud = new THREE.Mesh(studGeom, material);
        // Position stud relative to the center of the base box
        const studX = -width/2 + voxelUnit/2 + i * voxelUnit;
        const studY = height/2; // Position on top of the base
        stud.position.set(studX, studY, 0);
        stud.castShadow = true;
        brickGroup.add(stud);
    }

    // compute average center in grid coordinates then convert to world
    const avgX = voxels.reduce((s,v)=>s+v.x,0)/len;
    const avgY = voxels.reduce((s,v)=>s+v.y,0)/len;
    const avgZ = voxels.reduce((s,v)=>s+v.z,0)/len;

    // Position the entire group
    brickGroup.position.set(avgX * voxelUnit, avgY * voxelUnit, avgZ * voxelUnit);
    brickGroup.userData = {
        colorName,
        blockType: type,
        voxels: voxels.map(v=>({x:v.x,y:v.y,z:v.z}))
    };
    bear.add(brickGroup);
}

/* ---------- Selection & Highlighting ---------- */
function updateSelection(brick){
    selectedBrick = brick;
    const detailsPanel = document.getElementById('details-panel');

    if (brick) {
        selectionOutline.geometry.dispose();
        selectionOutline.geometry = new THREE.EdgesGeometry(brick.children[0].geometry); // Use the geometry of the base mesh
        selectionOutline.position.copy(brick.position);
        selectionOutline.visible = true;

        document.getElementById('detail-type').textContent = brick.userData.blockType;
        document.getElementById('detail-color').textContent = brick.userData.colorName;
        document.getElementById('detail-position').textContent = `X:${brick.userData.voxels[0].x}, Y:${brick.userData.voxels[0].y}, Z:${brick.userData.voxels[0].z}`;
        detailsPanel.classList.add('active');
    } else {
        selectionOutline.visible = false;
        detailsPanel.classList.remove('active');
    }
}
/* ---------- Raycasting / Interaction ---------- */
function onCanvasClick(event){
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(bear.children, true); // Set recursive to true

    if (intersects.length > 0){
        // The intersected object is a mesh (base or stud), we need its parent group.
        let brick = intersects[0].object;
        while (brick.parent && brick.parent !== bear) {
            brick = brick.parent;
        }

        updateSelection(brick);

        const oldColor = brick.userData.colorName;
        const newColor = selectedColorName;
        const type = brick.userData.blockType;

        if (oldColor === newColor) return;

        // Update mesh color
        brick.children.forEach(child => child.material.color.set(selectedColor));
        brick.userData.colorName = newColor;

        // Update voxel grid colors covered by this brick
        brick.userData.voxels.forEach(v=>{
            const key = `${v.x},${v.y},${v.z}`;
            if (voxelGrid[key]) voxelGrid[key].colorName = newColor;
        });

        // Update counts robustly (ensure keys exist)
        if (!blockCounts[oldColor]) blockCounts[oldColor] = { color: getHexForColorName(oldColor), '1x3':0,'1x2':0,'1x1':0, total:0 };
        if (!blockCounts[newColor]) blockCounts[newColor] = { color: getHexForColorName(newColor), '1x3':0,'1x2':0,'1x1':0, total:0 };

        blockCounts[oldColor][type] = Math.max(0, (blockCounts[oldColor][type]||0) - 1);
        blockCounts[oldColor].total = Math.max(0, (blockCounts[oldColor].total||0) - 1);

        blockCounts[newColor][type] = (blockCounts[newColor][type]||0) + 1;
        blockCounts[newColor].total = (blockCounts[newColor].total||0) + 1;

        renderBlockCountUI();
    }
}

/* ---------- Mouse drag / rotate ---------- */
function onMouseDown(e){
    isMouseDown = true;
    isDragging = false;
    previousMousePosition = {x:e.clientX,y:e.clientY};
}
function onMouseMove(e){
    if (isMouseDown) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        // If we've moved more than a few pixels, start dragging
        if (!isDragging && (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3)) {
            isDragging = true;
            if (selectedBrick) {
                updateSelection(null); // Clear selection when drag starts
            }
        }

        if (!isDragging) return;

        const target = new THREE.Vector3(0, 15, 0); // Point to orbit around.
        const offset = camera.position.clone().sub(target);

        // Rotate around the world's Y axis for horizontal drag
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
        // Rotate around the camera's X-axis for vertical drag
        offset.applyAxisAngle(camera.getWorldDirection(new THREE.Vector3()).cross(new THREE.Vector3(0, 1, 0)), (invertY ? -deltaY : deltaY) * 0.005);

        camera.position.copy(target).add(offset);
        camera.lookAt(target);
        previousMousePosition = {x:e.clientX, y:e.clientY};
    }
}
function onMouseUp(e){
    if (!isDragging) {
        onCanvasClick(e); // This was a click, not a drag
    }
    isMouseDown = false;
    isDragging = false;
}

/* ---------- Wheel zoom ---------- */
function onWheel(e){
    e.preventDefault();

    // 1. Find the point to zoom towards (under the cursor)
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    // Intersect with the bear and the ground plane
    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), voxelUnit);
    let targetPoint = new THREE.Vector3();
    const intersects = raycaster.intersectObject(bear, true);

    if (intersects.length > 0) {
        targetPoint = intersects[0].point;
    } else {
        raycaster.ray.intersectPlane(groundPlane, targetPoint);
    }

    // 2. Move camera towards that point
    const zoomFactor = e.deltaY > 0 ? 0.1 : -0.1;
    const dir = targetPoint.clone().sub(camera.position).multiplyScalar(zoomFactor);
    camera.position.add(dir);
}

/* ---------- Resize handler ---------- */
function onWindowResize(){
    const container = document.getElementById('canvas-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

/* ---------- Block counting UI ---------- */
function renderBlockCountUI(){
    const listEl = document.getElementById('block-list');
    listEl.innerHTML = '';
    const totalParts = { '1x3': 0, '1x2': 0, '1x1': 0, total: 0 };

    // Ensure consistent order
    const order = Object.keys(blockCounts).sort();
    order.forEach(colorName=>{
        const data = blockCounts[colorName];
        if (!data || data.total === 0) return;
        Object.keys(totalParts).forEach(key => totalParts[key] += data[key] || 0);

        const itemEl = document.createElement('div');
        itemEl.className = 'block-item';
        itemEl.style.borderLeftColor = data.color;
        itemEl.innerHTML = `
            <div class="block-item-header">
                <span class="block-color">${colorName}</span>
                <span class="block-total">${data.total}</span>
            </div>
            <div class="block-breakdown">
                <span>1√ó3: ${data['1x3']}</span>
                <span>1√ó2: ${data['1x2']}</span>
                <span>1√ó1: ${data['1x1']}</span>
            </div>
        `;
        listEl.appendChild(itemEl);
    });

    // Update total summary
    document.getElementById('total-pieces').textContent = totalParts.total;
    document.getElementById('total-1x3').textContent = `1x3: ${totalParts['1x3']}`;
    document.getElementById('total-1x2').textContent = `1x2: ${totalParts['1x2']}`;
    document.getElementById('total-1x1').textContent = `1x1: ${totalParts['1x1']}`;

    // Update price
    const totalPrice = (totalParts['1x1'] * PART_COSTS['1x1']) +
                       (totalParts['1x2'] * PART_COSTS['1x2']) +
                       (totalParts['1x3'] * PART_COSTS['1x3']);
    document.getElementById('price-value').textContent = `$${totalPrice.toFixed(2)}`;

    // Update layer slider
    const yLevels = Object.keys(blockCounts).flatMap(color => bear.children.filter(b => b.userData.colorName === color).map(b => b.userData.voxels[0].y));
    const maxLayer = yLevels.length > 0 ? Math.max(...yLevels) : 65;
    const slider = document.getElementById('layer-slider');
    slider.max = maxLayer;
    slider.value = maxLayer;
    document.getElementById('layer-label').textContent = `Layer: All`;
}

/* ---------- Controls ---------- */
function resetCamera(){
    camera.position.set(30,25,40);
    camera.lookAt(0,15,0);
    bear.rotation.set(0,0,0);
    // Reset layer slider
    const slider = document.getElementById('layer-slider');
    slider.value = slider.max;
    document.getElementById('layer-label').textContent = `Layer: All`;
    updateLayerVisibility(slider.max);
}

function switchModel(modelName) {
    if (modelName === currentModel) return;

    currentModel = modelName;

    // Update button styles
    document.querySelectorAll('.model-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.model-btn[data-model="${modelName}"]`).classList.add('active');

    // Update title
    document.querySelector('.hero h1').textContent = `Design Your Custom ${modelName.charAt(0).toUpperCase() + modelName.slice(1)}`;

    // Rebuild the scene with the new model
    if (modelName === 'bear') createBear()
    else if (modelName === 'penguin') createPenguin();
}
function toggleInvertControls(isChecked) {
    invertY = isChecked;
}


/* ---------- Modal / checkout ---------- */
function showInstructions(){ document.getElementById('modal').classList.add('active'); }
function closeModal(){ document.getElementById('modal').classList.remove('active'); }
function checkout(){
    alert('üî® BlockForge Demo\n\nIn production, this would:\n‚Ä¢ Process payment via Stripe\n‚Ä¢ Generate custom PDF instructions\n‚Ä¢ Send parts list to supplier\n‚Ä¢ Email confirmation to customer\n\nTotal Pieces: ' + document.getElementById('total-pieces').textContent + '\nPrice: ' + document.getElementById('price-value').textContent);
}

/* ---------- Instruction Generation ---------- */
async function generateInstructions() {
    const loadingIndicator = document.getElementById('instructions-loading');
    const modal = document.getElementById('modal');
    modal.classList.add('generating');
    loadingIndicator.style.display = 'block';
    document.querySelector('#modal .forge-button').style.display = 'none';
 
    const maxLayer = parseInt(document.getElementById('layer-slider').max, 10);
    let instructionHTML = `
        <html><head><title>BlockForge Instructions</title><style>
            body { font-family: sans-serif; }
            @page { size: A4; margin: 20mm; }
            .page { page-break-after: always; border: 1px solid #ccc; padding: 15px; border-radius: 10px; margin-bottom: 20px; }
            .page:last-child { page-break-after: avoid; }
            h1 { text-align: center; } h2 { border-bottom: 2px solid #eee; padding-bottom: 5px; }
            img { width: 100%; max-width: 600px; display: block; margin: 10px auto; border: 1px solid #ddd; border-radius: 8px; }
            .parts-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
            .part { background: #f4f4f4; padding: 5px 10px; border-radius: 5px; font-family: monospace; }
        </style></head><body><h1>BlockForge Build Guide</h1>
    `;

    const prevPos = camera.position.clone();
    const prevTarget = new THREE.Vector3(0, 15, 0); // Assuming this is the orbit target
    camera.lookAt(prevTarget);

    // Temporarily add edges for instructions
    bear.children.forEach(brickGroup => {
        const baseMesh = brickGroup.children[0];
        if (baseMesh && baseMesh.isMesh) {
            const edgesGeom = new THREE.EdgesGeometry(baseMesh.geometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
            const edges = new THREE.LineSegments(edgesGeom, edgesMaterial);
            edges.name = 'instruction_edge'; // Give it a name to find it later
            baseMesh.add(edges);
        }
    });

    // Set a consistent isometric view for all steps
    camera.position.set(0, 50, 25); // Bird's eye view
    camera.lookAt(0, 20, 0); // Look at the vertical center of the bear

    for (let i = 0; i <= maxLayer; i++) {
        // Get parts for the current layer
        const layerBricks = bear.children.filter(b => b.userData.voxels[0].y === i);
        if (layerBricks.length === 0) continue; // Skip empty layers

        const layerParts = {};
        layerBricks.forEach(brick => {
            const key = `${brick.userData.colorName}_${brick.userData.blockType}`;
            if (!layerParts[key]) layerParts[key] = { count: 0, color: brick.userData.colorName, type: brick.userData.blockType };
            layerParts[key].count++;
        });

        // Generate parts list HTML for the step
        let partsHTML = '<div class="parts-list">';
        Object.values(layerParts).forEach(p => {
            partsHTML += `<div class="part">${p.count}x ${p.color} ${p.type}</div>`;
        });
        partsHTML += '</div>';

        // Set visibility and capture image
        updateLayerVisibility(i); // Update which bricks are visible
        loadingIndicator.textContent = `Generating Instructions... Layer ${i + 1} / ${maxLayer + 1}`; // Update the text
        renderer.render(scene, camera); // Render the scene once
        await new Promise(resolve => setTimeout(resolve, 50)); // IMPORTANT: Wait for browser to repaint the screen

        // Get the image data
        const imgData = renderer.domElement.toDataURL('image/png');

        // Add to instruction document
        instructionHTML += `
            <div class="page">
                <h2>Step ${i + 1} (Layer ${i})</h2>
                ${partsHTML}
                <img src="${imgData}" />
            </div>
        `;
    }

    instructionHTML += '</body></html>';

    // Remove temporary edges
    bear.children.forEach(brickGroup => {
        const baseMesh = brickGroup.children[0];
        if (baseMesh && baseMesh.isMesh) {
            const edgeToRemove = baseMesh.getObjectByName('instruction_edge');
            if (edgeToRemove) {
                baseMesh.remove(edgeToRemove);
                edgeToRemove.geometry.dispose();
                edgeToRemove.material.dispose();
            }
        }
    });

    // Restore camera and visibility
    camera.position.copy(prevPos);
    camera.lookAt(prevTarget);
    updateLayerVisibility(maxLayer);
    
    // Create a downloadable link and click it
    const blob = new Blob([instructionHTML], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'BlockForge-Instructions.html';
    document.body.appendChild(link); link.click(); document.body.removeChild(link);
    URL.revokeObjectURL(url);

    loadingIndicator.style.display = 'none';
    document.querySelector('#modal .forge-button').style.display = 'block';
    modal.classList.remove('generating');
    closeModal();
}

/* ---------- Export image ---------- */
function exportImage(view){
    const prevPos = camera.position.clone(), prevRot = camera.rotation.clone();
    const target = new THREE.Vector3(0, 15, 0);
    if (view === 'front'){
        camera.position.set(0, 20, 50);
    } else if (view === 'back'){
        camera.position.set(0, 20, -50);
    } else if (view === 'side'){
        camera.position.set(50, 20, 0);
    }
    camera.lookAt(target);
    renderer.render(scene, camera);
    const dataURL = renderer.domElement.toDataURL('image/png');
    camera.position.copy(prevPos); camera.rotation.copy(prevRot); renderer.render(scene,camera);
    const link = document.createElement('a'); link.href = dataURL; link.download = `bear-${view}.png`; document.body.appendChild(link); link.click(); document.body.removeChild(link);
}

/* ---------- Init scene, lights, renderer, events, start ---------- */
function init(){
    const container = document.getElementById('canvas-container');
    const loadingDiv = container.querySelector('.loading');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8f9fa);

    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 2000);
    camera.position.set(30,25,40);
    camera.lookAt(0,15,0);
    originalCameraPosition = camera.position.clone();

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(20,30,20); dir.castShadow = true;
    dir.shadow.camera.left = -50; dir.shadow.camera.right = 50; dir.shadow.camera.top = 50; dir.shadow.camera.bottom = -50;
    dir.shadow.mapSize.width = 2048; dir.shadow.mapSize.height = 2048;
    scene.add(dir);
    const fill = new THREE.DirectionalLight(0xffffff, 0.25); fill.position.set(-15,10,-15); scene.add(fill);

    // Selection outline helper
    const outlineGeom = new THREE.BoxGeometry(1,1,1);
    const outlineEdges = new THREE.EdgesGeometry(outlineGeom);
    selectionOutline = new THREE.LineSegments(outlineEdges, new THREE.LineBasicMaterial({ color: 0xffcc00, linewidth: 3 }));
    selectionOutline.visible = false;
    scene.add(selectionOutline);

    // Ground
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({ color:0xe9ecef, roughness:0.9 }));
    ground.rotation.x = -Math.PI/2; ground.position.y = -voxelUnit; ground.receiveShadow = true;
    scene.add(ground);

    // Grid
    const gridHelper = new THREE.GridHelper(200, 100, 0xcccccc, 0xdddddd);
    gridHelper.position.y = -voxelUnit + 0.01; // Place slightly above ground to prevent z-fighting
    scene.add(gridHelper);

    // Build bear (this stores voxels then creates bricks)
    createBear();

    // Hide loading
    loadingDiv.style.display = 'none';

    // Events
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
    window.addEventListener('resize', onWindowResize);

    // Palette buttons
    document.querySelectorAll('.color-btn').forEach(btn=>{
        btn.addEventListener('click', ()=>{
            document.querySelectorAll('.color-btn').forEach(b=>b.classList.remove('active'));
            btn.classList.add('active');
            selectedColor = btn.dataset.color;
            selectedColorName = btn.dataset.name;
        });
    });

    // Layer slider event
    const layerSlider = document.getElementById('layer-slider');
    layerSlider.addEventListener('input', e => {
        const layer = parseInt(e.target.value, 10);
        document.getElementById('layer-label').textContent = layer == layerSlider.max ? `Layer: All` : `Layer: ${layer}`;
        updateLayerVisibility(layer);
    });

    animate();
}

function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

// geometry helpers reused from original
function onSphereSurface(x,y,z,cx,cy,cz,radius,thickness=0.8){
    const dx = x-cx, dy = y-cy, dz = z-cz;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    return dist >= radius - thickness && dist <= radius + thickness;
}
function onEllipsoidSurface(x,y,z,cx,cy,cz,rx,ry,rz,thickness=0.8){
    const dx = (x-cx)/rx, dy = (y-cy)/ry, dz = (z-cz)/rz;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    return dist >= 1 - thickness/rx && dist <= 1 + thickness/rx;
}

// Start
init();
</script>
</body>
</html>
