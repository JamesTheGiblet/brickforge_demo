<!doctype html>
<html lang="en">
<head>
  <link rel="stylesheet" href="assets/blockforge.css">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BlockForge - Mosaic Studio</title>
  <script src="assets/theme-switcher.js"></script>
  <script src="assets/partials/partials-loader.js"></script>
  <link rel="stylesheet" href="assets/themes.css">
  <style>
    body{font-family:Inter,system-ui,-apple-system,sans-serif; background:var(--bg-primary);color:var(--text-primary);margin:0;line-height:1.5; transition: background 0.3s, color 0.3s;}
    h1{margin:0 0 8px;font-size:24px;color:#fff;font-weight:800;letter-spacing:-0.5px}
    h2{font-size:14px;text-transform:uppercase;letter-spacing:1px;margin-top:0;color:var(--accent-primary);margin-bottom:12px}
    
    .layout{display:grid;grid-template-columns:350px 1fr;gap:24px;max-width:1400px;margin:2rem auto; padding: 0 2rem;}
    .card{background:var(--bg-secondary);padding:20px;border-radius:12px;border:1px solid var(--border-primary);box-shadow:0 10px 30px var(--shadow-primary)}
    
    label{display:block;margin:16px 0 8px;color:var(--text-muted);font-size:12px;font-weight:600;text-transform:uppercase}
    label:first-of-type{margin-top:0}
    
    /* Custom Range Slider */
    input[type=range]{width:100%;cursor:pointer;accent-color:var(--accent-primary)}
    
    input[type=text]{background:#111;border:1px solid #444;color:#fff;padding:8px;border-radius:6px;width:100%;box-sizing:border-box}
    
    .checkbox-row{display:flex;align-items:center;gap:12px;margin:16px 0;background:var(--bg-interactive);padding:10px;border-radius:6px;border:1px solid var(--border-primary)}
    .checkbox-row input{margin:0;width:16px;height:16px}
    .checkbox-row label{margin:0;text-transform:none;color:var(--text-secondary);font-size:14px}

    canvas{width:100%;height:auto;border-radius:8px;background:#000;box-shadow:0 4px 20px rgba(0,0,0,0.5)}
    .preview-wrap{display:flex;flex-direction:column;gap:16px}
    
    .stats-row{display:flex;gap:12px;margin-bottom:16px}
    .stat-box{background:var(--bg-tertiary);padding:12px;border-radius:8px;flex:1;text-align:center;border:1px solid var(--border-primary)}
    .stat-val{font-size:20px;font-weight:800;color:var(--text-primary)}
    .stat-label{font-size:11px;color:var(--text-muted);margin-top:4px}

    /* BOM Table */
    .bom-scroll{max-height:400px;overflow-y:auto;border:1px solid var(--border-primary);border-radius:6px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th{text-align:left;background:var(--bg-tertiary);color:var(--text-primary);position:sticky;top:0;padding:10px}
    td{border-bottom:1px solid var(--border-primary);padding:8px;color:var(--text-secondary)}
    tr:last-child td{border-bottom:none}
    .color-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;border:1px solid rgba(255,255,255,0.2)}

    @media (max-width: 900px) { .layout{grid-template-columns:1fr} }
  </style>
</head>
<body>
<div data-partial="nav" data-tool-title="Mosaic Tool"></div>
<!-- This tool uses a dark theme, so the standard light-themed header is omitted. -->
  <div class="layout">
    <h1 style="grid-column: 1 / -1;">Photo to Mosaic Studio</h1>
    <div class="card">
      <h2>1. Configuration</h2>
      
      <label>Source Image</label>
      <input id="file" type="file" accept="image/*" title="Select source image file">
      
      <label>Mosaic Width</label>
      <input id="width" type="range" min="16" max="256" value="80" title="Mosaic Width">
      <div style="font-size:12px;color:#aaa;text-align:right"><span id="width-val">80</span> studs</div>

      <label>Target Palette Size</label>
      <input id="colors" type="range" min="2" max="48" value="24" title="Target Palette Size">
      <div style="font-size:12px;color:#aaa;text-align:right"><span id="colors-val">24</span> colors</div>

      <div style="background:#222;padding:12px;border-radius:8px;margin-top:16px;border:1px solid #333">
        <label style="color:#fff;margin-top:0">Color Booster (Pre-process)</label>
        
        <label>Saturation Boost</label>
        <input id="saturation" type="range" min="0" max="100" value="40" title="Saturation Boost">
        
        <label>Contrast Boost</label>
        <input id="contrast" type="range" min="0" max="100" value="20" title="Contrast Boost">
      </div>

      <div class="checkbox-row">
        <input id="hslMatch" type="checkbox" checked>
        <label for="hslMatch"><strong>Use Vivid Matching (HSL)</strong><br><span style="font-size:11px;color:#888">Prioritizes vivid bricks over dull ones</span></label>
      </div>

      <div class="checkbox-row">
        <input id="avoidSeams" type="checkbox" checked>
        <label for="avoidSeams">Structure (Brick bond pattern)</label>
      </div>

      <label>Allowed Brick Sizes</label>
      <input id="bricksizes" type="text" value="4, 3, 2, 1" title="Allowed Brick Sizes (comma separated)" placeholder="e.g. 4, 3, 2, 1">
      
      <div class="controls">
        <button id="generate" class="btn btn-primary">GENERATE</button>
      </div>
      
      <div style="margin-top:20px;border-top:1px solid #333;padding-top:20px">
        <h2 style="margin-bottom:10px">Actions</h2>
        <div class="controls" style="margin-top:0">
          <button id="downloadPNG" class="btn btn-secondary">Save PNG</button>
          <button id="downloadCSV" class="btn btn-secondary">Export CSV</button>
        </div>
      </div>
    </div>

    <div class="preview-wrap">
      <div class="card">
        <h2>2. Visual Preview</h2>
        <canvas id="render"></canvas>
      </div>

      <div class="card" id="bom-card" style="display:none">
        <h2>3. Parts List</h2>
        <div class="stats-row">
          <div class="stat-box">
            <div class="stat-val" id="total-bricks">0</div>
            <div class="stat-label">Total Bricks</div>
          </div>
          <div class="stat-box">
            <div class="stat-val" id="total-colors">0</div>
            <div class="stat-label">Unique Colors</div>
          </div>
          <div class="stat-box">
            <div class="stat-val" id="est-cost">$0</div>
            <div class="stat-label">Est. Cost ($0.10/ea)</div>
          </div>
        </div>
        <div class="bom-scroll">
          <table id="bom-table">
            <thead><tr><th>Color</th><th>Size</th><th>Qty</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<script>
// --- EXPANDED "VIVID" PALETTE ---
// Includes standard colors + rare/vibrant ones.
// Hex codes are tuned for screen "pop" rather than dull realism.
const LEGO_PALETTE = [
  // Mono
  {name:"Black", hex:"#000000"},
  {name:"White", hex:"#FFFFFF"},
  {name:"Light Bluish Gray", hex:"#A0A5A9"},
  {name:"Dark Bluish Gray", hex:"#6C6E68"},
  // Reds/Pinks
  {name:"Red", hex:"#FF0000"}, // High Saturation
  {name:"Dark Red", hex:"#720E0F"},
  {name:"Coral", hex:"#FF5544"}, // Vivid
  {name:"Magenta", hex:"#E3008C"}, // Vivid
  {name:"Dark Pink", hex:"#C870A0"},
  {name:"Bright Pink", hex:"#FFBBFF"},
  // Oranges/Yellows
  {name:"Orange", hex:"#FF7700"},
  {name:"Yellow", hex:"#FFD700"},
  {name:"Bright Light Orange", hex:"#FFBB00"},
  {name:"Dark Orange", hex:"#A95500"},
  {name:"Neon Orange", hex:"#FF3300"}, // Rare but vivid
  // Greens
  {name:"Lime", hex:"#BBE90B"},
  {name:"Bright Green", hex:"#10CB31"}, // Vivid
  {name:"Green", hex:"#008F32"},
  {name:"Dark Green", hex:"#184632"},
  {name:"Olive Green", hex:"#9B9A5A"},
  {name:"Sand Green", hex:"#A0BCAC"},
  {name:"Yellowish Green", hex:"#DFEEA5"},
  // Blues/Azures
  {name:"Blue", hex:"#0055BF"},
  {name:"Dark Blue", hex:"#0A3463"},
  {name:"Medium Azure", hex:"#36AEBF"},
  {name:"Dark Azure", hex:"#078BC9"}, // Vivid
  {name:"Maersk Blue", hex:"#3592C3"},
  {name:"Sand Blue", hex:"#6074A1"},
  {name:"Dark Turquoise", hex:"#008F9B"},
  // Purples
  {name:"Medium Lavender", hex:"#AC78BA"},
  {name:"Lavender", hex:"#E1D5ED"},
  {name:"Purple", hex:"#81007B"},
  // Earth
  {name:"Reddish Brown", hex:"#582A12"},
  {name:"Dark Brown", hex:"#352100"},
  {name:"Tan", hex:"#E4CD9E"},
  {name:"Dark Tan", hex:"#958A73"},
  {name:"Medium Nougat", hex:"#CC702A"}
];

// --- APP STATE ---
const el = id => document.getElementById(id);
let imgBitmap = null;
let lastResult = null;

// --- LISTENERS ---
['width','colors'].forEach(id => {
  el(id).addEventListener('input', e => el(id+'-val').textContent = e.target.value);
});
el('file').addEventListener('change', e => {
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => { imgBitmap = img; URL.revokeObjectURL(url); };
  img.src = url;
});

// --- COLOR MATH (HSL) ---

// Convert RGB (0-255) to HSL (H:0-360, S:0-1, L:0-1)
function rgbToHsl(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h *= 60;
  }
  return [h, s, l];
}

function hexToRgb(hex) {
  const n = parseInt(hex.slice(1), 16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

// Find closest LEGO color using Hybrid Distance
function findBestLegoColor(r, g, b, useHslLogic) {
  let best = null;
  let minDiff = Infinity;
  
  const [srcH, srcS, srcL] = rgbToHsl(r,g,b);

  for (const lego of LEGO_PALETTE) {
    const [lr, lg, lb] = hexToRgb(lego.hex);
    
    let dist;
    if (useHslLogic) {
      // HSL Distance Strategy
      const [lh, ls, ll] = rgbToHsl(lr, lg, lb);
      
      // Calculate Hue difference (circular)
      let hDiff = Math.abs(srcH - lh);
      if (hDiff > 180) hDiff = 360 - hDiff;
      
      // WEIGHTS:
      // If the source pixel is Vivid (Sat > 0.3), heavily penalize Low Saturation bricks.
      let satPenalty = 0;
      if (srcS > 0.3 && ls < 0.2) satPenalty = 2.5; // Massive penalty for greys if we want color
      
      // Distance Formula
      // We weight Hue heavily, then Lightness, then Saturation
      dist = (hDiff/180 * 2.5) + (Math.abs(srcS - ls) * 1.5) + (Math.abs(srcL - ll) * 1.0) + satPenalty;
      
      // Special override: If source is near-grayscale, force grayscale matching
      if (srcS < 0.15) {
         // Switch to pure RGB brightness matching for greys
         dist = Math.abs(srcL - ll) * 5 + (ls * 10); // Penalty for any saturation
      }

    } else {
      // Standard RGB Euclidean (Old Way)
      dist = Math.sqrt((r-lr)**2 + (g-lg)**2 + (b-lb)**2);
    }

    if (dist < minDiff) {
      minDiff = dist;
      best = lego;
    }
  }
  return best;
}

// --- IMAGE PROCESSING ---

// Apply brightness/contrast/saturation
function preprocessImage(ctx, w, h, saturation, contrast) {
  const idata = ctx.getImageData(0,0,w,h);
  const d = idata.data;
  
  const satMul = 1 + (saturation/50); // 1.0 to 3.0
  const conMul = 1 + (contrast/100);
  const conOff = 128 * (1 - conMul);

  for(let i=0; i<d.length; i+=4) {
    let r=d[i], g=d[i+1], b=d[i+2];

    // Contrast
    r = r * conMul + conOff;
    g = g * conMul + conOff;
    b = b * conMul + conOff;

    // Saturation
    const gray = 0.2989*r + 0.5870*g + 0.1140*b;
    r = gray + (r - gray) * satMul;
    g = gray + (g - gray) * satMul;
    b = gray + (b - gray) * satMul;

    d[i] = Math.max(0,Math.min(255,r));
    d[i+1] = Math.max(0,Math.min(255,g));
    d[i+2] = Math.max(0,Math.min(255,b));
  }
  ctx.putImageData(idata, 0, 0);
  return idata;
}

// K-Means Quantization
function quantize(pixels, k) {
  // Simple K-Means
  const centers = [];
  const n = pixels.length/4;
  for(let i=0;i<k;i++) {
    const idx = Math.floor(Math.random()*n)*4;
    centers.push([pixels[idx], pixels[idx+1], pixels[idx+2]]);
  }
  
  const assign = new Int32Array(n);
  for(let iter=0; iter<10; iter++){
    // Assign
    for(let i=0; i<n; i++){
      const r=pixels[i*4], g=pixels[i*4+1], b=pixels[i*4+2];
      let bestD = Infinity, bestC = 0;
      for(let c=0; c<k; c++){
        const d = (r-centers[c][0])**2 + (g-centers[c][1])**2 + (b-centers[c][2])**2;
        if(d<bestD){ bestD=d; bestC=c; }
      }
      assign[i] = bestC;
    }
    // Update
    const sums = Array.from({length:k}, ()=>([0,0,0,0]));
    for(let i=0; i<n; i++){
      const c = assign[i];
      sums[c][0]+=pixels[i*4]; sums[c][1]+=pixels[i*4+1]; sums[c][2]+=pixels[i*4+2]; sums[c][3]++;
    }
    for(let c=0; c<k; c++){
      if(sums[c][3]>0) {
        centers[c][0] = sums[c][0]/sums[c][3];
        centers[c][1] = sums[c][1]/sums[c][3];
        centers[c][2] = sums[c][2]/sums[c][3];
      }
    }
  }
  return {centers, assign};
}

// --- MAIN GENERATOR ---

async function generate() {
  if(!imgBitmap) { alert("Please select an image first."); return; }
  
  const widthVal = parseInt(el('width').value);
  const colorCount = parseInt(el('colors').value);
  const brickSizes = el('bricksizes').value.split(',').map(Number).sort((a,b)=>b-a);
  const useHsl = el('hslMatch').checked;
  const avoidSeams = el('avoidSeams').checked;

  // 1. Resize & Preprocess
  const ratio = imgBitmap.height / imgBitmap.width;
  const heightVal = Math.round(widthVal * ratio);
  
  const cvs = document.createElement('canvas');
  cvs.width = widthVal; cvs.height = heightVal;
  const ctx = cvs.getContext('2d');
  ctx.drawImage(imgBitmap, 0, 0, widthVal, heightVal);
  
  const idata = preprocessImage(ctx, widthVal, heightVal, 
                               parseInt(el('saturation').value), 
                               parseInt(el('contrast').value));

  // 2. Quantize
  const q = quantize(idata.data, colorCount);

  // 3. Map to LEGO
  const legoMap = q.centers.map(c => findBestLegoColor(c[0], c[1], c[2], useHsl));
  
  // 4. Build Grid
  const grid = [];
  for(let y=0; y<heightVal; y++) {
    const row = [];
    for(let x=0; x<widthVal; x++) {
      const idx = y*widthVal + x;
      row.push(legoMap[q.assign[idx]]);
    }
    grid.push(row);
  }

  // 5. Pack Bricks
  const bricks = [];
  let prevSeams = new Set();
  
  for(let y=0; y<heightVal; y++) {
    let x = 0;
    const currentSeams = new Set();
    
    while(x < widthVal) {
      const color = grid[y][x];
      let bestSize = 1;
      
      // Find largest fit
      for(const size of brickSizes) {
        if(x + size > widthVal) continue;
        
        // Check color continuity
        let match = true;
        for(let k=0; k<size; k++) if(grid[y][x+k] !== color) match = false;
        if(!match) continue;

        // Check seams
        const endX = x + size;
        if(avoidSeams && prevSeams.has(endX) && endX !== widthVal) continue;
        
        bestSize = size;
        break;
      }
      
      bricks.push({x, y, size: bestSize, color: color.hex, name: color.name});
      if(x + bestSize < widthVal) currentSeams.add(x + bestSize);
      x += bestSize;
    }
    prevSeams = avoidSeams ? currentSeams : new Set();
  }

  lastResult = { bricks, w:widthVal, h:heightVal };
  renderMosaic(bricks, widthVal, heightVal);
  renderBOM(bricks);
}

// --- RENDERING ---
function renderMosaic(bricks, w, h) {
  const cvs = el('render');
  const stud = 12; // px per stud
  cvs.width = w * stud;
  cvs.height = h * stud;
  const ctx = cvs.getContext('2d');
  
  // Background
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,cvs.width,cvs.height);

  for(const b of bricks) {
    const x = b.x * stud;
    const y = b.y * stud;
    const bw = b.size * stud;
    
    // Base Brick
    ctx.fillStyle = b.color;
    ctx.fillRect(x+1, y+1, bw-2, stud-2);
    
    // Studs
    for(let i=0; i<b.size; i++) {
      const sx = x + i*stud + stud/2;
      const sy = y + stud/2;
      const r = stud * 0.35;
      
      // Stud Shadow
      ctx.beginPath();
      ctx.arc(sx+1, sy+1, r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fill();

      // Stud Top
      ctx.beginPath();
      ctx.arc(sx, sy, r, 0, Math.PI*2);
      ctx.fillStyle = b.color;
      ctx.fill();
      
      // Highlight (Glossy Plastic Look)
      ctx.beginPath();
      ctx.arc(sx - r*0.3, sy - r*0.3, r*0.25, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fill();
      
      // Rim
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(sx, sy, r, 0, Math.PI*2); ctx.stroke();
    }
  }
}

function renderBOM(bricks) {
  const counts = {};
  bricks.forEach(b => {
    const k = b.name + '|' + b.size + '|' + b.color;
    if(!counts[k]) counts[k] = 0;
    counts[k]++;
  });
  
  const rows = Object.entries(counts).map(([k, count]) => {
    const [name, size, hex] = k.split('|');
    return {name, size:parseInt(size), hex, count};
  }).sort((a,b) => b.count - a.count); // Sort by quantity

  const tbody = el('bom-table').querySelector('tbody');
  tbody.innerHTML = '';
  
  const uniqueCols = new Set();
  
  rows.forEach(r => {
    uniqueCols.add(r.name);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="color-dot" style="background:${r.hex}"></span>${r.name}</td>
      <td>1 x ${r.size}</td>
      <td>${r.count}</td>
    `;
    tbody.appendChild(tr);
  });
  
  el('bom-card').style.display = 'block';
  el('total-bricks').textContent = bricks.length;
  el('total-colors').textContent = uniqueCols.size;
  el('est-cost').textContent = '$' + (bricks.length * 0.10).toFixed(2);
}

// --- EXPORT ---
el('generate').addEventListener('click', generate);

el('downloadPNG').addEventListener('click', () => {
  if(!lastResult) return;
  const link = document.createElement('a');
  link.download = 'lego-mosaic-vivid.png';
  link.href = el('render').toDataURL();
  link.click();
});

el('downloadCSV').addEventListener('click', () => {
  if(!lastResult) return;
  let csv = "x,y,size,color_name,color_hex\n";
  lastResult.bricks.forEach(b => {
    csv += `${b.x},${b.y},${b.size},"${b.name}",${b.color}\n`;
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url; link.download = 'bricks.csv';
  link.click();
});

</script>
</body>
</html>